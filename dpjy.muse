* 引入
** 灵梦的灵符
博丽灵梦是东方幻想乡中博丽神社的巫女，她跟幻想乡中最老资格的妖怪八云紫一起维护着隔绝幻想乡与现实世界的大结界，维护现实世界不被幻想乡中的妖怪侵害，幻想乡中的生物也可以自由自在的维持古老的生活方式。但不幸的是，每隔六十年，结界会有一次大异变，为了维护结界的完整，博丽灵梦必须将灵力注入灵符，让灵力以最好的方式游走来修复结界。灵梦的灵符是一个三角形，由一堆数字组成，每个数字表示灵力经过这个位置获得的修复值，三角形共n层，第i层有i个数字，从上方的最尖端注入灵力，灵力只能前往前位置的左下方或者右下方，最终走的下面的边的某个位置释放，问灵梦最多可以获得多少修复值？

** 最容易想到的方法：回溯
列举每一条可能的路线，分别累加比较每条路线的修复值进行比较，取得最大的一条作为答案。我们先不引入时间复杂度的计算，来用一个n较小的例子手工计算我们需要做的计算量。很明显，对于n＝＝4，共有2^(4-1)＝8条不同的路线，如果不考虑回溯时的计算量，每条路线我们要进行两次加法和一次比较，共24次计算。这很小，但是如果n=100呢？n=1000呢？指数级的运算量将会飞快增长，无法接受
** 为什么会计算那么多次呢？
因为这个算法有天然呆的属性，太健忘了，还是n＝＝4的例子，第四层中间2个点的计算，都用到了第3层中间的点，而中间的点又分别来自第2层的两个点，由乘法原理，分别计算了2*2＝＝4次，正是这种乘法原理造成了指数级的计算量，因为不同路线多次经过同一个点，到这个点为止的最大和其实已经算出来了，可以直接用它来与下面路线获得的修复值相加就可以获得最终的最大值，而回溯法在回溯时会重复计算这个值//其实这就是后面要说的最优子结构
** 换一种方法：
如上所说，到第2层中间点的时候，有两种路线，如果取当前和较大的一种路线记录下来，往下走的时候直接用这个数跟下面点的修复值相加，对于每一层都看做一个这样的问题，也就是到当前位置可以获得的最大值，依次类推。到最下面一层时就获得了原问题答案：到最下面某个位置（也就是最后一层子问题的［当前位置］）的最大修复值。这就是动态规划的算法。
** 这样的计算次数
每个点最多会从它上面的两个点走过来，取它们最优值较大的一个，然后加上这个点的值，共进行1次比较和1次加法，（1+4）*4/2=10个点，共计算20次，虽然只少了4次，但n增长时与n^2成正比的计算量就可以接受了。
* 动态规划的定义，特点和适用条件

